"""
The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """Deferred when true."""
  if: Boolean

  """
  If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """Streamed when true."""
  if: Boolean

  """The initial elements that shall be send down to the consumer."""
  initialCount: Int!

  """
  If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String
) on FIELD

"""
The `Byte` scalar type represents non-fractional whole numeric values. Byte can represent values between 0 and 255.
"""
scalar Byte

type CardModel {
  checksum: [Byte!]
  id: Int!
  name: LocaleModel!
  url: String
}

"""A connection to a list of items."""
type CategoriesConnection {
  """A list of edges."""
  edges: [CategoriesEdge!]

  """A flattened list of the nodes."""
  nodes: [CategoryModel!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

"""An edge in a connection."""
type CategoriesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: CategoryModel!
}

type CategoryModel {
  franchises: [FranchiseModel!]!
  id: Int!
  name: LocaleModel!
  persons: [PersonModel!]!
}

input CategoryModelFilterInput {
  and: [CategoryModelFilterInput!]
  franchises: ListFilterInputTypeOfFranchiseModelFilterInput
  id: ComparableInt32OperationFilterInput
  name: LocaleModelFilterInput
  or: [CategoryModelFilterInput!]
  persons: ListFilterInputTypeOfPersonModelFilterInput
}

input CategoryModelSortInput {
  id: SortEnumType
  name: LocaleModelSortInput
}

input ComparableInt32OperationFilterInput {
  eq: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  neq: Int
  ngt: Int
  ngte: Int
  nin: [Int!]
  nlt: Int
  nlte: Int
}

input CreateCardInput {
  file: String!
  franchises: [Int!]!
  name: LocaleValueInput!
  tags: [Int!]!
}

input CreateCategoryInput {
  name: LocaleValueInput!
}

input CreateFranchiseInput {
  name: LocaleValueInput!
  tags: [Int!]!
}

input CreateTagInput {
  name: LocaleValueInput!
}

type FranchiseModel {
  categories: [CategoryModel!]!
  id: Int!
  name: LocaleModel!
  tags: [TagModel!]!
}

input FranchiseModelFilterInput {
  and: [FranchiseModelFilterInput!]
  categories: ListFilterInputTypeOfCategoryModelFilterInput
  id: ComparableInt32OperationFilterInput
  name: LocaleModelFilterInput
  or: [FranchiseModelFilterInput!]
  tags: ListFilterInputTypeOfTagModelFilterInput
}

input FranchiseModelSortInput {
  id: SortEnumType
  name: LocaleModelSortInput
}

"""A connection to a list of items."""
type FranchisesConnection {
  """A list of edges."""
  edges: [FranchisesEdge!]

  """A flattened list of the nodes."""
  nodes: [FranchiseModel!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

"""An edge in a connection."""
type FranchisesEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: FranchiseModel!
}

input ListFilterInputTypeOfCategoryModelFilterInput {
  all: CategoryModelFilterInput
  any: Boolean
  none: CategoryModelFilterInput
  some: CategoryModelFilterInput
}

input ListFilterInputTypeOfFranchiseModelFilterInput {
  all: FranchiseModelFilterInput
  any: Boolean
  none: FranchiseModelFilterInput
  some: FranchiseModelFilterInput
}

input ListFilterInputTypeOfPersonModelFilterInput {
  all: PersonModelFilterInput
  any: Boolean
  none: PersonModelFilterInput
  some: PersonModelFilterInput
}

input ListFilterInputTypeOfTagModelFilterInput {
  all: TagModelFilterInput
  any: Boolean
  none: TagModelFilterInput
  some: TagModelFilterInput
}

type LocaleModel {
  en: String!
  franchises: [FranchiseModel!]!
  id: Int!
  jp: String!
  kr: String!
  persons: [PersonModel!]!
  ru: String!
  tags: [TagModel!]!
}

input LocaleModelFilterInput {
  and: [LocaleModelFilterInput!]
  en: StringOperationFilterInput
  franchises: ListFilterInputTypeOfFranchiseModelFilterInput
  id: ComparableInt32OperationFilterInput
  jp: StringOperationFilterInput
  kr: StringOperationFilterInput
  or: [LocaleModelFilterInput!]
  persons: ListFilterInputTypeOfPersonModelFilterInput
  ru: StringOperationFilterInput
  tags: ListFilterInputTypeOfTagModelFilterInput
}

input LocaleModelSortInput {
  en: SortEnumType
  id: SortEnumType
  jp: SortEnumType
  kr: SortEnumType
  ru: SortEnumType
}

input LocaleValueInput {
  en: String!
  jp: String!
  kr: String!
  ru: String!
}

type Mutation {
  addCard(input: CreateCardInput!): CardModel!
  addCategory(input: CreateCategoryInput!): CategoryModel!
  addFranchise(input: CreateFranchiseInput!): FranchiseModel!
  addTag(input: CreateTagInput!): TagModel!
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: String

  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String
}

type PersonModel {
  categories: [CategoryModel!]!
  franchises: [FranchiseModel!]!
  id: Int!
  name: LocaleModel!
  tags: [TagModel!]!
}

input PersonModelFilterInput {
  and: [PersonModelFilterInput!]
  categories: ListFilterInputTypeOfCategoryModelFilterInput
  franchises: ListFilterInputTypeOfFranchiseModelFilterInput
  id: ComparableInt32OperationFilterInput
  name: LocaleModelFilterInput
  or: [PersonModelFilterInput!]
  tags: ListFilterInputTypeOfTagModelFilterInput
}

type Query {
  categories(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    order: [CategoryModelSortInput!]
    where: CategoryModelFilterInput
  ): CategoriesConnection
  franchises(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    order: [FranchiseModelSortInput!]
    where: FranchiseModelFilterInput
  ): FranchisesConnection
  tags(
    """Returns the elements in the list that come after the specified cursor."""
    after: String

    """
    Returns the elements in the list that come before the specified cursor.
    """
    before: String

    """Returns the first _n_ elements from the list."""
    first: Int

    """Returns the last _n_ elements from the list."""
    last: Int
    order: [TagModelSortInput!]
    where: TagModelFilterInput
  ): TagsConnection
}

enum SortEnumType {
  ASC
  DESC
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  contains: String
  endsWith: String
  eq: String
  in: [String]
  ncontains: String
  nendsWith: String
  neq: String
  nin: [String]
  nstartsWith: String
  or: [StringOperationFilterInput!]
  startsWith: String
}

type TagModel {
  franchises: [FranchiseModel!]!
  id: Int!
  name: LocaleModel!
  persons: [PersonModel!]!
}

input TagModelFilterInput {
  and: [TagModelFilterInput!]
  franchises: ListFilterInputTypeOfFranchiseModelFilterInput
  id: ComparableInt32OperationFilterInput
  name: LocaleModelFilterInput
  or: [TagModelFilterInput!]
  persons: ListFilterInputTypeOfPersonModelFilterInput
}

input TagModelSortInput {
  id: SortEnumType
  name: LocaleModelSortInput
}

"""A connection to a list of items."""
type TagsConnection {
  """A list of edges."""
  edges: [TagsEdge!]

  """A flattened list of the nodes."""
  nodes: [TagModel!]

  """Information to aid in pagination."""
  pageInfo: PageInfo!
  totalCount: Int!
}

"""An edge in a connection."""
type TagsEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: TagModel!
}
